---
layout: post
title: "Java并发-锁机制"
subtitle: '可重入锁、可中断锁、公平锁、多condition、乐观锁、悲观锁'
author: "xiaojiejava"
header-style: text
tags:
  - Lock
  - Synchronized
  - ReentrantLock
  - AQS
  - CAS
---
早期的计算机不包含操作系统，每次只能运行一个程序，整个程序从头到尾占用计算机的所有资源，这对于昂贵和稀缺的计算机资源是一种极大的浪费。
后来有了操作系统，有了进程的概念。每个进程占用一块属于自己的计算机资源，不同进程的资源互相隔离、互不影响。通过进程支持并发多任务执行。
进程太重，每次切换造的成本很高，有了线程的概念，每个进程下面可以有多个线程，任务由线程执行，线程的上下文切换成本远低于进程的上下文切换成本。

对于单CPU计算机而言，大部分操作系统多线程的执行是时间片轮转的抢占式调度，什么意思是呢？就是将连续的时间分成一小段一小段的，每一段称为时间片，线程执行就是分配了一个时间片，执行时间到达后，调度其它线程执行（将后续的时间片分配给其它线程），由于CPU运转速度很快，在人能感知的时间范围内有大量的时间分片，每个时间片特别短，给人的感觉就是多个任务"同时"在执行。

对于多CPU计算机而言，是真正意义上的多任务同时执行.

多线程优势:
1. 充分利用计算机资源，提升系统的效率和吞吐率
2. 程序响应更快，像Tomcat、Netty等都是利用多线程处理用户请求

多线程劣势:
1. 上下文切换开销
2. 每个线程需要占用一定的计算机资源
3. 带来编码的复杂性，需要考虑的变多，比如多线程资源共享并发安全的问题

本文主要讲述解决多线程安全(race condition)问题的锁机制

### Synchronized(Java 1.6及以后)
首先了解下对象在内存中的布局:

分为三块，对象头、实例数据和对齐填充字节

对象头又由三块组成，mark word、指向class类型的指针和数组长度(如果有数组则有这块，否则没有)

mark word(标记字段),采用不定长的方式，用于存储运行时对象自身的数据。
1. hash码
2. gc分代年龄
3. 锁标记 01无锁或偏向锁 00轻量级锁 10重量级锁 
4. 偏向锁标记 0无锁 1偏向锁
5. 偏向线程ID
6. 偏向时间戳

偏向锁：
当第一个线程执行到synchronized代码块的时候，首先会CAS更改mark word的偏向锁标记和偏向线程ID(设置为当前线程ID)，这样就标识了这个线程持有这个偏向锁，需要注意如果一直没有别的线程进来竞争则这个偏向锁不会释放，会一直存在。

轻量级锁：
当第二个线程执行到synchronized代码块的时候，发现有线程持有偏向锁，则根据线程ID找对应的线程的状态，如果线程已经结束或者已经退出同步代码块，则尝试获取偏向锁。否则锁膨胀为轻量级锁，等待线程执行到安全点后执行。轻量级锁的实现是在当前线程栈中开辟出一块专门的空间，然后将mark word copy到这个空间，称之为replaced mark word,然后mark word存储的是到displaced mark word的指针，如果cas成功则线程获取到锁，否则自适应自旋。

重量级锁：
当第二个线程自旋一定时间还没获取到锁，或者有第三个及以上线程进入synchronzied代码块竞争锁的时候，锁膨胀为重量级锁，同样等待持有锁的线程的安全点到达后执行膨胀。重量级锁会发生系统调用，性能损耗是三者中最大的。

自旋锁: 
当线程获取不到锁的时候，不是立即进入阻塞等待状态，而是自旋尝试获取锁。因为通常线程执行很快释放锁也就很快，自旋等待的成本可能低于线程阻塞等待产生的上下文切换的成本。当然它也存在一定问题，一直自旋尝试获取锁占用cpu资源。所以JVM采用的是自适应自旋。

### ReentrantLock

从java1.5开始提供了外置锁，从名字上可以看出这个锁是可重入的，可重入的意思是一个线程可以多次获取同一个锁而不会发生阻塞，synchronized也是可重入的，RenntrantLock提供了很多高级特性，比如公平/非公平锁、可中断锁、tryLock、多Condition、超时锁等。


公平/非公平锁: 
指的是是否根据锁的获取顺序分配锁，即先申请锁的线程一定比后申请锁的线程先得到锁，非公平锁则没有这个保证。

ReentrantLock内部有FairSync和NonFairSync，可以通过构建对象时指定是否用公平锁，默认非公平锁。非公平锁比公平锁的吞吐量要高。

可中断锁(lockInterruptibly): 
对于synchronized锁来说，一旦进入同步代码块阻塞等待获得锁，则再调用thread.interrupt()将不起任何作用，即synchronized响应不了中断。对于ReentrantLock来说，当调用的是lockInterruptibly阻塞等待获取锁时，调用thread.interrupt()会响应中断抛出异常。---这里的自动可中断只的都是对于线程一直未获得锁，等待锁的时候响应的中断

需要注意：无论对于synchronized还是reentrantLock来说，一旦线程获取了锁正在执行代码逻辑，这时候调用thread.interrupt(),当前线程都会被标记为interrupted，这时候要想响应中断必须在线程里自己写代码监测判断Thread.interrupted()状态，如果为true做出中断响应即可。

tryLock: 
可以尝试获取锁，获取不到不阻塞而是直接返回，由应用程序决定下一步操作。

多condition:
更精细的粒度控制，一个锁有多个condition，notify的时候不用通知所有的wait线程，只需要精准通知等待某个condition的wait线程。BlockingQueue就是利用这个实现的.

超时锁: 
可以调用lock方法的时候执行超时时间，在指定时间内获取不到锁则直接返回，避免长时间等待。

应用: 
CyclicBarrier
ConcurrentHashMap分段锁(java1.7)

劣势: 
必须人工在finally中调用unlock释放锁，可能存在忘记释放锁的问题.

何时使用: 
优先使用synchronized当其满足不了需求需要用到高级特性时用ReentrantLock.

### AQS(Abstract Queued Synchronizer) ReentrantLock底层实现

CAS:首先了解下CAS，即compare-and-swap比较和替换，存在三个基本操作数，内存地址 旧值 新值，当更新的时候只有旧值等于内存地址对应的值才会将内存地址的值更新为新值，否则更新失败。在并发较低的情况下，CAS比锁具有更好的性能。但是它有占用CPU资源和ABA等问题。

AQS底层维护了一个变量volatile int state,如果一个线程想要获取锁则cas这个值如果cas成功则获取到锁，否则封装为AQS内部对象放到锁等待队列中。当释放锁的时候同样执行cas操作，并通知队列中的下一个等待线程。上面讲到的ReentrantLock的公平锁的实现是当线程发现队列中有等待的线程，不会竞争锁，直接进入队列。非公平锁会尝试竞争锁，所以可能比队列中已有的线程优先获取到锁。

独占锁: 只有一个线程能同时获取到锁，对应AQS实现为cas到某个值成功则获得锁，否则等待。
共享锁：多个线程能同时获取到，对应AWS实现为cas到某个<count的值则获取到锁，否则等待。

CountDownLatch: 
利用AQS实现，state的大小表示可同时持有锁的线程个数，每个线程调用countDown的时候回将state-1，减至0的时候唤醒主线程。

ReentrantReadWriteLock: 
利用AQS实现，state分为高16位和低16位，低16位独占写锁，高16位共享读锁。

### Optimistic Lock 乐观锁

乐观锁不是锁特性而是锁的一种使用方式，乐观的认为没有并发或者并发很少，所以先不加锁，等真正更新的时候利用CAS机制更新，如果更新失败再重试。

### Pessimistic Lock 悲观锁

悲观锁不是锁特性而是锁的一种使用方式，悲观的认为并发一定会发生，在执行操作之前先锁住资源，保证没有其他线程可以操作资源。

### CAS与Synchronized使用场景分析

对于资源竞争较少的场景，因为CAS基于硬件实现，不需要切换线程，自旋的几率又小，所以可以获得更高的性能。
而对于写竞争压力较大，并发很多的场景，CAS范围会浪费CPU资源，性能不如Synchronized。

### ThreadLocal
上面讲到的解决并发问题的方案是对同一个共享资源加锁，ThreadLocal提供了另外一种思路每个线程内部独占资源，互不影响。
ThreadLocal的实现原理是，在Thread里面维护一个ThreadLocalMap,其中key为ThreadLocal对象，value为往ThreadLocal中设置的值，从而实现对象绑定到线程，避免并发问题。

应用实例: 
保存数据库连接，实现事务
保存SimpleDateFormat(1.8及以后用DateTimeFormatter替代)

踩坑记录: 
通常我们都用线程池实现线程复用，避免频繁创建成本和资源耗尽风险。比如对于Tomcat而言内部是线程池机制，一个请求过来后分配一个线程处理，设置对象到ThreadLocal中，线程使用对象，请求结束，线程自动回到线程池。这个流程缺失了一个清空ThreadLocal对象的操作，因为线程复用，如果不清空，别的线程在复用的时候可能拿到之前线程设置到ThreadLocal中的值。


### 线程池

可以设想一下，如果没有池，每次需要线程的时候直接新建一个，如果某一时刻大量请求涌入会创建大量的线程，然而对于服务器或单进程而言，可承受的最大线程个数是有上限的，如果不限制必然会导致超过上限，整个服务直接挂掉。每次线程的新建都需要时间，通过线程池实现线程复用避免了频繁创建的开销。java提供了线程池的支持。

ThreadPoolExecutor的构造参数:
1. corePoolSize 核心线程个数
2. maximumPoolSize 最大的线程个数
3. keepAliveTime、unit 超过核心线程数的线程空闲的时间
4. BlockingQueue<Runnable> workQueue 阻塞队列
5. RejectedExecutionHandler handler

各个参数作用为当需要分配线程的时候
1. 如果线程池个数 < corePoolSize,则直接新建一个线程处理。否则将请求放入阻塞队列。
2. 阻塞队列有有限和无限阻塞队列之分，如果是无限阻塞队列则后续所有的请求都会放到这个队列（坑:需要注意如果无限堆积可能OOM）。
3. 如果是有限队列当队列满后会创建线程到maximumPoolSize个，超过corePoolSize的线程会空闲timeout时间自动退出。
4. 如果线程池的个数已经达到了maximumPoolSize，再有请求进来就要执行Reject policy,有如下四种policy.

    1. AbortPolicy 直接抛出异常
    2. DiscardPolicy 直接丢弃当前任务
    3. DiscardOldestPolicy 直接丢弃最老的任务
    4. CallerRunsPolicy 直接用请求线程池的线程的线程执行任务

踩坑记录: 调用.execute(Runnable command)会command执行过程抛出异常会直接打印出来，调用.submit()方法且没有调用future.get()的时候不会打印异常。

如何正确的关闭线程池:



