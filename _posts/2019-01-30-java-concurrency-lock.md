---
layout: post
title: "Java并发-锁机制"
subtitle: '可重入锁、可中断锁、公平锁、多condition、乐观锁、悲观锁'
author: "xiaojiejava"
header-style: text
tags:
  - Lock
  - Synchronized
  - ReentrantLock
  - AQS
  - CAS
---
早期的计算机不包含操作系统，每次只能运行一个程序，整个程序从头到尾占用计算机的所有资源，这对于昂贵和稀缺的计算机资源是一种极大的浪费。
后来有了操作系统，有了进程的概念。每个进程占用一块属于自己的计算机资源，不同进程的资源互相隔离、互不影响。通过进程支持并发多任务执行。
进程太重，每次切换造的成本很高，有了线程的概念，每个进程下面可以有多个线程，任务由线程执行，线程的上下文切换成本远低于进程的上下文切换成本。

对于单CPU计算机而言，大部分操作系统多线程的执行是时间片轮转的抢占式调度，什么意思是呢？就是将连续的时间分成一小段一小段的，每一段称为时间片，线程执行就是分配了一个时间片，执行时间到达后，调度其它线程执行（将后续的时间片分配给其它线程），由于CPU运转速度很快，在人能感知的时间范围内有大量的时间分片，每个时间片特别短，给人的感觉就是多个任务"同时"在执行。

对于多CPU计算机而言，是真正意义上的多任务同时执行.

多线程优势:
1. 充分利用计算机资源，提升系统的效率和吞吐率
2. 程序响应更快，像Tomcat、Netty等都是利用多线程处理用户请求

多线程劣势:
1. 上下文切换开销
2. 每个线程需要占用一定的计算机资源
3. 带来编码的复杂性，需要考虑的变多，比如多线程资源共享并发安全的问题

本文主要讲述解决多线程安全(race condition)问题的锁机制

### Synchronized(Java 1.6即以后)
首先了解下对象在内存中的布局:

分为三块，对象头、实例数据和对齐填充字节

对象头又由三块组成，mark word、指向class类型的指针和数组长度(如果有数组则有这块，否则没有)

mark word(标记字段),采用不定长的方式，用于存储运行时对象自身的数据。
1. hash码
2. gc分代年龄
3. 锁标记 01无锁或偏向锁 00轻量级锁 10重量级锁 
4. 偏向锁标记 0无锁 1偏向锁
5. 偏向线程ID
6. 偏向时间戳

偏向锁：
当第一个线程执行到synchronized代码块的时候，首先会CAS更改mark word的偏向锁标记和偏向线程ID(设置为当前线程ID)，这样就标识了这个线程持有这个偏向锁，需要注意如果一直没有别的线程进来竞争则这个偏向锁不会释放，会一直存在。

轻量级锁：
当第二个线程执行到synchronized代码块的时候，发现有线程持有偏向锁，则根据线程ID找对应的线程的状态，如果线程已经结束或者已经退出同步代码块，则尝试获取偏向锁。否则锁膨胀为轻量级锁，等待线程执行到安全点后执行。轻量级锁的实现是在当前线程栈中开辟出一块专门的空间，然后将mark word copy到这个空间，称之为replaced mark word,然后mark word存储的是到displaced mark word的指针，如果cas成功则线程获取到锁，否则自适应自旋。

重量级锁：
当第二个线程自旋一定时间还没获取到锁，或者有第三个及以上线程进入synchronzied代码块竞争锁的时候，锁膨胀为重量级锁，同样等待持有锁的线程的安全点到达后执行膨胀。重量级锁会发生系统调用，性能损耗是三者中最大的。

自旋锁: 
当线程获取不到锁的时候，不是立即进入阻塞等待状态，而是自旋尝试获取锁。因为通常线程执行很快释放锁也就很快，自旋等待的成本可能低于线程阻塞等待产生的上下文切换的成本。当然它也存在一定问题，一直自旋尝试获取锁占用cpu资源。所以JVM采用的是自适应自旋。

### ReentrantLock

从java1.5开始提供了外置锁，从名字上可以看出这个锁是可重入的，可重入的意思是一个线程可以多次获取同一个锁而不会发生阻塞，synchronized也是可重入的，RenntrantLock提供了很多高级特性，比如公平/非公平锁、可中断锁、tryLock、多Condition、超时锁等。


公平/非公平锁: 
指的是是否根据锁的获取顺序分配锁，即先申请锁的线程一定比后申请锁的线程先得到锁，非公平锁则没有这个保证。

ReentrantLock内部有FairSync和NonFairSync，可以通过构建对象时指定是否用公平锁，默认非公平锁。非公平锁比公平锁的吞吐量要高。

可中断锁(lockInterruptibly): 
即尝试获取锁的线程可以响应中断请求停止阻塞

tryLock: 
可以尝试获取锁，获取不到不阻塞而是直接返回，由应用程序决定下一步操作。

多condition:
更精细的粒度控制，一个锁有多个condition，notify的时候不用通知所有的wait线程，只需要精准通知等待某个condition的wait线程。BlockingQueue就是利用这个实现的.

超时锁: 
可以调用lock方法的时候执行超时时间，在指定时间内获取不到锁则直接返回，避免长时间等待。

应用: 
CyclicBarrier
ConcurrentHashMap分段锁(java1.7)

劣势: 
必须人工在finally中调用unlock释放锁，可能存在忘记释放锁的问题.

何时使用: 
优先使用synchronized当其满足不了需求需要用到高级特性时用ReentrantLock.

### AQS(AbstractQueuedSynchronizer) ReentrantLock底层实现

CAS:首先了解下CAS，即compare-and-swap比较和替换，存在三个基本操作数，内存地址 旧值 新值，当更新的时候只有旧值等于内存地址对应的值才会将内存地址的值更新为新值，否则更新失败。在并发较低的情况下，CAS比锁具有更好的性能。但是它有占用CPU资源和ABA等问题。

AQS底层维护了一个变量volatile int state,如果一个线程想要获取锁则cas这个值如果cas成功则获取到锁，否则封装为AQS内部对象放到锁等待队列中。当释放锁的时候同样执行cas操作，并通知队列中的下一个等待线程。上面讲到的ReentrantLock的公平锁的实现是当线程发现队列中有等待的线程，不会竞争锁，直接进入队列。非公平锁会尝试竞争锁，所以可能比队列中已有的线程优先获取到锁。

CountDownLatch: 
利用AQS实现，state的大小表示可同时持有锁的线程个数，每个线程调用countDown的时候回将state-1，减至0的时候欢迎主线程。

ReentrantReadWriteLock: 
利用AQS实现，state分为高16位和低16位，低16位独占写锁，高16位共享锁读锁。

独占锁: 只有一个线程能同时获取到锁，对应AQS实现为cas到某个值成功则获得锁，否则等待。
共享锁：多个线程能同时获取到，对应AWS实现为cas到某个<count的值则获取到锁，否则等待。

### Optimistic Lock 乐观锁


### Pessimistic Lock 悲观锁



### 线程池
### ThreadLocal



