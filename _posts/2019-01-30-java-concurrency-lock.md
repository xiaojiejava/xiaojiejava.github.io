---
layout: post
title: "Java并发-锁机制"
subtitle: '可重入锁、可中断锁、公平锁、多condition、乐观锁、悲观锁'
author: "xiaojiejava"
header-style: text
tags:
  - Lock
  - Synchronized
  - ReentrantLock
  - AQS
  - CAS
---
早期的计算机不包含操作系统，每次只能运行一个程序，整个程序从头到尾占用计算机的所有资源，这对于昂贵和稀缺的计算机资源是一种极大的浪费。
后来有了操作系统，有了进程的概念。每个进程占用一块属于自己的计算机资源，不同进程的资源互相隔离、互不影响。通过进程支持并发多任务执行。
进程太重，每次切换造的成本很高，有了线程的概念，每个进程下面可以有多个线程，任务由线程执行，线程的上下文切换成本远低于进程的上下文切换成本。

对于单CPU计算机而言，大部分操作系统多线程的执行是时间片轮转的抢占式调度，什么意思是呢？就是将连续的时间分成一小段一小段的，每一段称为时间片，线程执行就是分配了一个时间片，执行时间到达后，调度其它线程执行（将后续的时间片分配给其它线程），由于CPU运转速度很快，在人能感知的时间范围内有大量的时间分片，每个时间片特别短，给人的感觉就是多个任务"同时"在执行。

对于多CPU计算机而言，是真正意义上的多任务同时执行.

多线程优势:
1. 充分利用计算机资源，提升系统的效率和吞吐率
2. 程序响应更快，像Tomcat、Netty等都是利用多线程处理用户请求

多线程劣势:
1. 上下文切换开销
2. 每个线程需要占用一定的计算机资源
3. 带来编码的复杂性，需要考虑的变多，比如多线程资源共享并发安全的问题

本文主要讲述解决多线程安全(race condition)问题的锁机制

### Synchronized
首先了解下对象在内存中的布局:

分为三块，对象头、实例数据和对齐填充字节

对象头又由三块组成，mark word、指向class类型的指针和数组长度(如果有数组则有这块，否则没有)

mark word(标记字段),采用不定长的方式，用于存储运行时对象自身的数据。
1. hash码
2. gc分代年龄
3. 锁标记 01无锁或偏向锁 00轻量级锁 10重量级锁 
4. 偏向锁标记 0无锁 1偏向锁
5. 偏向线程ID
6. 偏向时间戳

偏向锁：
当第一个线程执行到synchronized代码块的时候，首先会CAS更改mark word的偏向锁标记和偏向线程ID(设置为当前线程ID)，这样就标识了这个线程持有这个偏向锁，需要注意如果一直没有别的线程进来竞争则这个偏向锁不会释放，会一直存在。

轻量级锁：
当第二个线程执行到synchronized代码块的时候，发现有线程持有偏向锁，则根据线程ID找对应的线程的状态，如果线程已经结束或者已经退出同步代码块，则尝试获取偏向锁。否则锁膨胀为轻量级锁，等待线程执行到安全点后执行。轻量级锁的实现是在当前线程栈中开辟出一块专门的空间，然后将mark word copy到这个空间，然后cas mark word指针到新开辟的空间，如果cas成功则线程获取到锁，否则自适应自旋。

重量级锁：
当第二个线程自旋一定时间还没获取到锁，或者有第三个及以上线程进入synchronzied代码块竞争锁的时候，锁膨胀为重量级锁，同样等待持有锁的线程的安全点到达后执行膨胀。重量级锁会发生系统调用，性能损耗是三者中最大的。

自旋锁: 
当线程获取不到锁的时候，不是立即进入阻塞等待状态，而是自旋尝试获取锁。因为通常线程执行很快释放锁也就很快，自旋等待的成本可能低于线程阻塞等待产生的上下文切换的成本。当然它也存在一定问题，一直自旋尝试获取锁占用cpu资源。所以JVM采用的是自适应自旋。

### ReentrantLock
公平锁:

可中断:

多condition:

超时锁:

### Optimistic Lock
### Pessimistic Lock
### AQS
cas:

### 线程池
### ThreadLocal



