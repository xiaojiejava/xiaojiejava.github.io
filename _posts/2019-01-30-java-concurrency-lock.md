---
layout: post
title: "Java并发-锁机制"
subtitle: '可重入锁、可中断锁、公平锁、多condition、乐观锁、悲观锁'
author: "xiaojiejava"
header-style: text
tags:
  - Lock
  - Synchronized
  - ReentrantLock
  - AQS
  - CAS
---
早期的计算机不包含操作系统，每次只能运行一个程序，整个程序从头到尾占用计算机的所有资源，这对于昂贵和稀缺的计算机资源是一种极大的浪费。
后来有了操作系统，有了进程的概念。每个进程占用一块属于自己的计算机资源，不同进程的资源互相隔离、互不影响。通过进程支持并发多任务执行。
进程太重，每次切换造的成本很高，有了线程的概念，每个进程下面可以有多个线程，任务由线程执行，线程的上下文切换成本远低于进程的上下文切换成本。

对于单CPU计算机而言，大部分操作系统多线程的执行是时间片轮转的抢占式调度，什么意思是呢？就是将连续的时间分成一小段一小段的，每一段称为时间片，线程执行就是分配了一个时间片，执行时间到达后，调度其它线程执行（将后续的时间片分配给其它线程），由于CPU运转速度很快，在人能感知的时间范围内有大量的时间分片，每个时间片特别短，给人的感觉就是多个任务"同时"在执行。

对于多CPU计算机而言，是真正意义上的多任务同时执行.

多线程优势:
1. 充分利用计算机资源，提升系统的效率和吞吐率
2. 程序响应更快，像Tomcat、Netty等都是利用多线程处理用户请求

多线程劣势:
1. 上下文切换开销
2. 每个线程需要占用一定的计算机资源
3. 带来编码的复杂性，需要考虑的变多，比如多线程资源共享并发安全的问题

本文主要讲述解决多线程安全(race condition)问题的锁机制

### Synchronized
对象头:

偏向锁：

轻量级锁：

重量级锁：

自旋锁:

### ReentrantLock
公平锁:

可中断:

多condition:

超时锁:

### Optimistic Lock
### Pessimistic Lock
### AQS
cas:

### 线程池



